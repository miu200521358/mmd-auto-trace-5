<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Joint Viewer (Babylon.js)</title>
  <script src="https://cdn.babylonjs.com/babylon.js"></script>
  <style>
    :root {
      --color-trunk: #23a6d5;
      --color-left: #4ad66d;
      --color-right: #ff6b6b;
    }
    html, body {
      width: 100%;
      height: 100%;
      margin: 0;
      overflow: hidden;
      background: #0f1115;
      color: #e6e6e6;
      font-family: "Segoe UI", "Helvetica Neue", Arial, sans-serif;
    }
    body {
      display: flex;
      flex-direction: column;
    }
    #toolbar {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 8px;
      padding: 8px 10px;
      background: #12151c;
      border-bottom: 1px solid #20242d;
      font-size: 12px;
    }
    #toolbar label {
      display: inline-flex;
      align-items: center;
      gap: 6px;
    }
    #toolbar input[type="number"] {
      width: 60px;
    }
    #toolbar input[type="range"] {
      width: 200px;
    }
    #dropZone {
      margin: 6px 10px;
      padding: 8px;
      border: 1px dashed #2f3746;
      border-radius: 6px;
      text-align: center;
      color: #8b96a5;
      background: #12151c;
      font-size: 12px;
    }
    #dropZone.dragover {
      border-color: #5aa9e6;
      background: #182233;
      color: #cfe6ff;
    }
    #renderCanvas {
      flex: 1;
      width: 100%;
      height: 100%;
      display: block;
    }
    #tooltip {
      position: fixed;
      display: none;
      padding: 6px 8px;
      background: rgba(20, 23, 30, 0.95);
      border: 1px solid #2a313d;
      border-radius: 6px;
      font-size: 12px;
      line-height: 1.4;
      pointer-events: none;
      white-space: pre;
      z-index: 10;
    }
    #status {
      margin-left: auto;
      color: #9aa3ad;
    }
    #legend {
      display: inline-flex;
      gap: 6px;
      align-items: center;
      margin-left: 6px;
    }
    .legend-item {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 2px 6px;
      border-radius: 10px;
      background: #1b1f27;
    }
    .swatch {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      display: inline-block;
    }
  </style>
</head>
<body>
  <div id="toolbar">
    <input type="file" id="fileInput" accept=".json" multiple>
    <button id="loadDefault">Load default JSON</button>
    <label>Space
      <select id="jointSpace">
        <option value="global_3d_joints">global_3d_joints</option>
        <option value="3d_joints">3d_joints</option>
      </select>
    </label>
    <label>Frame
      <input type="range" id="frameSlider" min="0" max="0" value="0">
    </label>
    <span id="frameLabel">-</span>
    <button id="playBtn">Play</button>
    <label>FPS
      <input type="number" id="fps" value="30" min="1" max="60">
    </label>
    <label>Scale
      <input type="number" id="scale" value="1" step="0.1">
    </label>
    <label>
      <input type="checkbox" id="centerOnPelvis">
      Center on pelvis
    </label>
    <div id="legend">
      <span class="legend-item">
        <span class="swatch" style="background: var(--color-trunk)"></span>
        trunk
      </span>
      <span class="legend-item">
        <span class="swatch" style="background: var(--color-left)"></span>
        left
      </span>
      <span class="legend-item">
        <span class="swatch" style="background: var(--color-right)"></span>
        right
      </span>
    </div>
    <span id="status">Load a JSON file to begin.</span>
  </div>
  <div id="dropZone">Drop JSON files here</div>
  <canvas id="renderCanvas"></canvas>
  <div id="tooltip"></div>
  <script>
    (() => {
      const DEFAULT_JSON = "../../../sources/45seconds/output/json/joints_3d_human_0.json";
      const AXIS_MAP = { x: "x", y: "y", z: "z" };
      const AXIS_SIGN = { x: 1, y: 1, z: 1 };

      const GROUP_COLORS = {
        trunk: getCssColor("--color-trunk"),
        left: getCssColor("--color-left"),
        right: getCssColor("--color-right"),
      };

      // Edit only this section to add/remove chains.
      const CHAINS = [
        { group: "trunk", chain: ["head", "jaw", "neck", "spine3", "spine2", "spine1", "pelvis"] },
        { group: "left", chain: ["neck", "left_collar", "left_shoulder", "left_elbow", "left_wrist"] },
        { group: "right", chain: ["neck", "right_collar", "right_shoulder", "right_elbow", "right_wrist"] },
        { group: "right", chain: ["pelvis", "right_hip", "right_knee", "right_ankle", "right_foot", "right_big_toe"] },
        { group: "left", chain: ["pelvis", "left_hip", "left_knee", "left_ankle", "left_foot", "left_big_toe"] },
        { group: "left", chain: ["left_ear", "left_eye", "nose1"] },
        { group: "right", chain: ["right_ear", "right_eye", "nose1"] },
      ];

      const canvas = document.getElementById("renderCanvas");
      const engine = new BABYLON.Engine(canvas, true, { preserveDrawingBuffer: true, stencil: true });
      const scene = new BABYLON.Scene(engine);
      scene.useRightHandedSystem = false;
      scene.clearColor = new BABYLON.Color4(0.06, 0.06, 0.07, 1.0);

      const camera = new BABYLON.ArcRotateCamera(
        "camera",
        Math.PI / 2,
        Math.PI / 2.4,
        4,
        new BABYLON.Vector3(0, 1, 0),
        scene
      );

      camera.attachControl(canvas, false);

      // 入力割り当て（MMD互換）
      const pointerInput = camera.inputs.attached.pointers;
      pointerInput.buttons = [1, 2];   // 中・右
      pointerInput.panningButton = 1;  // 中＝パン

      // 操作感調整
      camera.angularSensibilityX = 1200;
      camera.angularSensibilityY = 1200;
      camera.panningSensibility = 1000;
      camera.wheelPrecision = 50;

      // 安定性
      camera.lowerBetaLimit = 0.01;
      camera.upperBetaLimit = Math.PI - 0.01;
      camera.lowerRadiusLimit = 0.2;
      camera.minZ = 0.001;

      // 右クリックメニュー抑止
      canvas.addEventListener("contextmenu", ev => ev.preventDefault());

      const light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0, 1, 0), scene);
      light.intensity = 0.9;

      createAxis(scene, 0.4);

      let datasets = [];
      let datasetMap = new Map();
      let globalFrameKeys = [];
      let playingTimer = null;
      let cameraFitted = false;
      let dragDepth = 0;

      const fileInput = document.getElementById("fileInput");
      const loadDefaultBtn = document.getElementById("loadDefault");
      const jointSpace = document.getElementById("jointSpace");
      const frameSlider = document.getElementById("frameSlider");
      const frameLabel = document.getElementById("frameLabel");
      const playBtn = document.getElementById("playBtn");
      const fpsInput = document.getElementById("fps");
      const scaleInput = document.getElementById("scale");
      const centerOnPelvis = document.getElementById("centerOnPelvis");
      const status = document.getElementById("status");
      const tooltip = document.getElementById("tooltip");
      const dropZone = document.getElementById("dropZone");

      fileInput.addEventListener("change", (ev) => {
        if (!ev.target.files || ev.target.files.length === 0) {
          return;
        }
        loadFiles(ev.target.files);
      });

      loadDefaultBtn.addEventListener("click", async () => {
        setStatus("Loading default JSON...");
        stopPlayback();
        clearDatasets();
        try {
          const res = await fetch(DEFAULT_JSON);
          if (!res.ok) {
            throw new Error("HTTP " + res.status);
          }
          const text = await res.text();
          addDatasetFromText(text, "default", 0);
          finalizeLoad();
        } catch (err) {
          setStatus("Default load failed. Use file input.");
          console.warn(err);
        }
      });

      jointSpace.addEventListener("change", () => updateFrame(frameSlider.valueAsNumber));
      frameSlider.addEventListener("input", () => updateFrame(frameSlider.valueAsNumber));
      scaleInput.addEventListener("change", () => updateFrame(frameSlider.valueAsNumber));
      centerOnPelvis.addEventListener("change", () => updateFrame(frameSlider.valueAsNumber));

      playBtn.addEventListener("click", () => {
        if (playingTimer) {
          stopPlayback();
        } else {
          startPlayback();
        }
      });

      document.body.addEventListener("dragenter", onDragEnter);
      document.body.addEventListener("dragover", onDragOver);
      document.body.addEventListener("dragleave", onDragLeave);
      document.body.addEventListener("drop", onDrop);

      function onDragEnter(ev) {
        ev.preventDefault();
        dragDepth += 1;
        dropZone.classList.add("dragover");
      }

      function onDragOver(ev) {
        ev.preventDefault();
      }

      function onDragLeave(ev) {
        ev.preventDefault();
        dragDepth = Math.max(0, dragDepth - 1);
        if (dragDepth === 0) {
          dropZone.classList.remove("dragover");
        }
      }

      function onDrop(ev) {
        ev.preventDefault();
        dragDepth = 0;
        dropZone.classList.remove("dragover");
        if (ev.dataTransfer && ev.dataTransfer.files && ev.dataTransfer.files.length > 0) {
          loadFiles(ev.dataTransfer.files);
        }
      }

      function startPlayback() {
        if (globalFrameKeys.length === 0) {
          return;
        }
        const fps = clamp(parseInt(fpsInput.value, 10) || 30, 1, 60);
        playBtn.textContent = "Stop";
        playingTimer = setInterval(() => {
          const next = (frameSlider.valueAsNumber + 1) % globalFrameKeys.length;
          frameSlider.value = String(next);
          updateFrame(next);
        }, 1000 / fps);
      }

      function stopPlayback() {
        clearInterval(playingTimer);
        playingTimer = null;
        playBtn.textContent = "Play";
      }

      async function loadFiles(fileList) {
        stopPlayback();
        clearDatasets();
        const files = Array.from(fileList);
        if (files.length === 0) {
          return;
        }
        setStatus("Loading " + files.length + " file(s)...");
        try {
          const texts = await Promise.all(files.map(readFileAsText));
          texts.forEach((text, idx) => {
            addDatasetFromText(text, files[idx].name, idx);
          });
          finalizeLoad();
        } catch (err) {
          setStatus("File load failed.");
          console.warn(err);
        }
      }

      function readFileAsText(file) {
        return new Promise((resolve, reject) => {
          const reader = new FileReader();
          reader.onload = () => resolve(reader.result);
          reader.onerror = () => reject(reader.error);
          reader.readAsText(file);
        });
      }

      function addDatasetFromText(text, label, fallbackIndex) {
        let parsed;
        try {
          parsed = parseJsonText(text);
        } catch (err) {
          setStatus("JSON parse error: " + label);
          console.error(err);
          return false;
        }
        if (!parsed.frames || typeof parsed.frames !== "object") {
          setStatus("Missing frames in JSON: " + label);
          return false;
        }
        return addDataset(parsed, label, fallbackIndex);
      }

      function addDataset(parsed, label, fallbackIndex) {
        const frameKeys = Object.keys(parsed.frames).sort((a, b) => Number(a) - Number(b));
        if (frameKeys.length === 0) {
          return false;
        }
        const joints = findFirstJoints(parsed.frames, frameKeys);
        if (!joints) {
          return false;
        }
        const humanIndex = parsed.human_index !== undefined
          ? parsed.human_index
          : extractHumanIndex(label, fallbackIndex);
        const datasetId = "dataset_" + humanIndex + "_" + datasets.length;
        const dataset = {
          id: datasetId,
          label,
          humanIndex,
          frames: parsed.frames,
          frameKeys,
          jointNames: Object.keys(joints),
          jointBase: null,
          jointMeshes: {},
          lines: [],
          currentPositions: {},
        };
        buildDatasetMeshes(dataset);
        datasets.push(dataset);
        datasetMap.set(datasetId, dataset);
        return true;
      }

      function finalizeLoad() {
        rebuildGlobalFrames();
        if (globalFrameKeys.length === 0 || datasets.length === 0) {
          setStatus("No valid frames found.");
          return;
        }
        cameraFitted = false;
        frameSlider.min = "0";
        frameSlider.max = String(Math.max(0, globalFrameKeys.length - 1));
        frameSlider.value = "0";
        updateFrame(0);
        setStatus("Loaded " + datasets.length + " file(s). Frames: " + globalFrameKeys.length);
      }

      function rebuildGlobalFrames() {
        const keySet = new Set();
        datasets.forEach((dataset) => {
          dataset.frameKeys.forEach((key) => keySet.add(key));
        });
        globalFrameKeys = Array.from(keySet).sort((a, b) => Number(a) - Number(b));
        if (globalFrameKeys.length === 0) {
          frameLabel.textContent = "-";
        }
      }

      function updateFrame(index) {
        if (globalFrameKeys.length === 0) {
          return;
        }
        const frameKey = globalFrameKeys[index];
        frameLabel.textContent = frameKey + " / " + globalFrameKeys[globalFrameKeys.length - 1];
        const scale = parseFloat(scaleInput.value) || 1;
        const centerName = centerOnPelvis.checked ? "pelvis" : null;
        const allPositions = [];
        datasets.forEach((dataset) => {
          const frame = dataset.frames[frameKey];
          if (!frame) {
            hideDataset(dataset);
            return;
          }
          const joints = frame[jointSpace.value] || frame.global_3d_joints || frame["3d_joints"];
          if (!joints) {
            hideDataset(dataset);
            return;
          }
          const posMap = buildPositionMap(joints, scale, centerName);
          dataset.currentPositions = posMap;
          updateDatasetLines(dataset, posMap);
          updateDatasetJoints(dataset, posMap);
          Object.values(posMap).forEach((p) => allPositions.push(p));
        });
        fitCameraOnce(allPositions);
      }

      function hideDataset(dataset) {
        dataset.lines.forEach((line) => {
          if (line) {
            line.isVisible = false;
          }
        });
        Object.values(dataset.jointMeshes).forEach((mesh) => {
          mesh.isVisible = false;
        });
      }

      function updateDatasetLines(dataset, posMap) {
        CHAINS.forEach((cfg, idx) => {
          const points = [];
          let hasAll = true;
          cfg.chain.forEach((name) => {
            const pos = posMap[name];
            if (!pos) {
              hasAll = false;
            }
            points.push(pos || new BABYLON.Vector3(0, 0, 0));
          });
          if (!dataset.lines[idx]) {
            const line = BABYLON.MeshBuilder.CreateLines(
              "chain_" + dataset.id + "_" + idx,
              { points, updatable: true },
              scene
            );
            line.color = GROUP_COLORS[cfg.group] || GROUP_COLORS.trunk;
            line.isPickable = false;
            dataset.lines[idx] = line;
          } else {
            BABYLON.MeshBuilder.CreateLines(
              "chain_" + dataset.id + "_" + idx,
              { points, instance: dataset.lines[idx] }
            );
          }
          dataset.lines[idx].isVisible = hasAll;
        });
      }

      function updateDatasetJoints(dataset, posMap) {
        Object.keys(dataset.jointMeshes).forEach((name) => {
          const mesh = dataset.jointMeshes[name];
          const pos = posMap[name];
          if (!pos) {
            mesh.isVisible = false;
            return;
          }
          mesh.position.copyFrom(pos);
          mesh.isVisible = true;
        });
      }

      function buildDatasetMeshes(dataset) {
        if (dataset.jointBase) {
          dataset.jointBase.dispose();
        }
        Object.values(dataset.jointMeshes).forEach((mesh) => mesh.dispose());
        dataset.jointMeshes = {};
        dataset.jointBase = BABYLON.MeshBuilder.CreateSphere(
          "joint_base_" + dataset.id,
          { diameter: 0.03 },
          scene
        );
        const mat = new BABYLON.StandardMaterial("joint_mat_" + dataset.id, scene);
        mat.diffuseColor = new BABYLON.Color3(0.95, 0.95, 0.95);
        dataset.jointBase.material = mat;
        dataset.jointBase.isVisible = false;
        dataset.jointBase.isPickable = false;
        dataset.jointNames.forEach((name) => {
          const inst = dataset.jointBase.createInstance("joint_" + dataset.id + "_" + name);
          inst.metadata = { jointName: name, datasetId: dataset.id, humanIndex: dataset.humanIndex };
          inst.isPickable = true;
          dataset.jointMeshes[name] = inst;
        });
      }

      function buildPositionMap(joints, scale, centerName) {
        const positions = {};
        let center = null;
        if (centerName && joints[centerName]) {
          center = toVector(joints[centerName], scale);
        }
        Object.keys(joints).forEach((name) => {
          const pos = toVector(joints[name], scale);
          positions[name] = center ? pos.subtract(center) : pos;
        });
        return positions;
      }

      function toVector(joint, scale) {
        const x = (joint[AXIS_MAP.x] || 0) * AXIS_SIGN.x * scale;
        const y = (joint[AXIS_MAP.y] || 0) * AXIS_SIGN.y * scale;
        const z = (joint[AXIS_MAP.z] || 0) * AXIS_SIGN.z * scale;
        return new BABYLON.Vector3(x, y, z);
      }

      function findFirstJoints(frames, frameKeys) {
        for (const key of frameKeys) {
          const frame = frames[key];
          if (!frame) {
            continue;
          }
          const joints = frame[jointSpace.value] || frame.global_3d_joints || frame["3d_joints"];
          if (joints && Object.keys(joints).length > 0) {
            return joints;
          }
        }
        return null;
      }

      function extractHumanIndex(label, fallbackIndex) {
        if (typeof label !== "string") {
          return fallbackIndex;
        }
        const match = label.match(/human[_-](\d+)/i);
        if (match) {
          return match[1];
        }
        const numeric = label.match(/(\d+)/);
        if (numeric) {
          return numeric[1];
        }
        return fallbackIndex;
      }

      function clearDatasets() {
        datasets.forEach((dataset) => disposeDataset(dataset));
        datasets = [];
        datasetMap = new Map();
        globalFrameKeys = [];
      }

      function disposeDataset(dataset) {
        dataset.lines.forEach((line) => {
          if (line) {
            line.dispose();
          }
        });
        Object.values(dataset.jointMeshes).forEach((mesh) => mesh.dispose());
        if (dataset.jointBase) {
          dataset.jointBase.dispose();
        }
      }

      function fitCameraOnce(points) {
        if (cameraFitted) {
          return;
        }
        const bounds = getBounds(points);
        if (!bounds) {
          return;
        }
        camera.target.copyFrom(bounds.center);
        camera.radius = Math.max(bounds.radius * 2.5, 1.5);
        cameraFitted = true;
      }

      function getBounds(points) {
        if (!points || points.length === 0) {
          return null;
        }
        let min = points[0].clone();
        let max = points[0].clone();
        points.forEach((p) => {
          min = BABYLON.Vector3.Minimize(min, p);
          max = BABYLON.Vector3.Maximize(max, p);
        });
        const center = min.add(max).scale(0.5);
        const radius = BABYLON.Vector3.Distance(center, max);
        return { center, radius };
      }

      function parseJsonText(text) {
        const cleaned = text.replace(/^\uFEFF/, "");
        const idx = cleaned.indexOf("{");
        if (idx > 0) {
          return JSON.parse(cleaned.slice(idx));
        }
        return JSON.parse(cleaned);
      }

      function setStatus(message) {
        status.textContent = message;
      }

      function clamp(value, min, max) {
        return Math.min(Math.max(value, min), max);
      }

      function getCssColor(varName) {
        const value = getComputedStyle(document.documentElement).getPropertyValue(varName).trim();
        return hexToColor3(value || "#ffffff");
      }

      function hexToColor3(hex) {
        const value = hex.replace("#", "");
        const r = parseInt(value.slice(0, 2), 16) / 255;
        const g = parseInt(value.slice(2, 4), 16) / 255;
        const b = parseInt(value.slice(4, 6), 16) / 255;
        return new BABYLON.Color3(r, g, b);
      }

      function createAxis(scene, size) {
        const axisX = BABYLON.MeshBuilder.CreateLines("axisX", {
          points: [new BABYLON.Vector3(0, 0, 0), new BABYLON.Vector3(size, 0, 0)]
        }, scene);
        axisX.color = new BABYLON.Color3(1, 0, 0);
        axisX.isPickable = false;
        const axisY = BABYLON.MeshBuilder.CreateLines("axisY", {
          points: [new BABYLON.Vector3(0, 0, 0), new BABYLON.Vector3(0, size, 0)]
        }, scene);
        axisY.color = new BABYLON.Color3(0, 1, 0);
        axisY.isPickable = false;
        const axisZ = BABYLON.MeshBuilder.CreateLines("axisZ", {
          points: [new BABYLON.Vector3(0, 0, 0), new BABYLON.Vector3(0, 0, size)]
        }, scene);
        axisZ.color = new BABYLON.Color3(0, 0.6, 1);
        axisZ.isPickable = false;
      }

      scene.onPointerObservable.add((pointerInfo) => {
        if (pointerInfo.type !== BABYLON.PointerEventTypes.POINTERMOVE) {
          return;
        }
        const pick = scene.pick(scene.pointerX, scene.pointerY, (mesh) => {
          return mesh && mesh.metadata && mesh.metadata.jointName;
        });
        if (!pick || !pick.hit || !pick.pickedMesh) {
          tooltip.style.display = "none";
          return;
        }
        const meta = pick.pickedMesh.metadata;
        const jointName = meta.jointName;
        const dataset = datasetMap.get(meta.datasetId);
        if (!dataset) {
          tooltip.style.display = "none";
          return;
        }
        const pos = dataset.currentPositions[jointName];
        if (!pos) {
          tooltip.style.display = "none";
          return;
        }
        tooltip.textContent =
          "human_index: " + meta.humanIndex +
          "\n" +
          jointName +
          "\n" +
          "x: " + pos.x.toFixed(4) +
          "  y: " + pos.y.toFixed(4) +
          "  z: " + pos.z.toFixed(4);
        tooltip.style.left = pointerInfo.event.clientX + 12 + "px";
        tooltip.style.top = pointerInfo.event.clientY + 12 + "px";
        tooltip.style.display = "block";
      });

      engine.runRenderLoop(() => {
        scene.render();
      });
      window.addEventListener("resize", () => engine.resize());
    })();
  </script>
</body>
</html>
